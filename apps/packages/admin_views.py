"""
Admin Analytics Dashboard for Experiences
Provides insights into experience performance, revenue, and selection patterns
"""

from decimal import Decimal
from typing import Dict, List

from django.contrib.admin.views.decorators import staff_member_required
from django.db.models import Count, Q, Sum
from django.shortcuts import render
from django.utils.decorators import method_decorator
from django.views import View

from bookings.models import Booking

from .models import Experience


@method_decorator(staff_member_required, name="dispatch")
class ExperienceAnalyticsDashboard(View):
    """
    Analytics dashboard for experience performance
    Shows top experiences, revenue, and selection patterns
    """

    def get(self, request):
        context = {
            "top_experiences": self._get_top_experiences(),
            "revenue_by_experience": self._get_revenue_by_experience(),
            "category_stats": self._get_category_statistics(),
            "city_stats": self._get_city_statistics(),
            "recent_trends": self._get_recent_trends(),
            "summary_stats": self._get_summary_statistics(),
        }
        return render(request, "admin/packages/analytics_dashboard.html", context)

    def _get_top_experiences(self) -> List[Dict]:
        """Get top 10 most selected experiences"""
        # Count how many times each experience appears in confirmed bookings
        top_experiences = (
            Experience.objects.filter(
                booking__status__in=["CONFIRMED", "PENDING_PAYMENT"]
            )
            .annotate(selection_count=Count("booking"))
            .order_by("-selection_count")[:10]
        )

        return [
            {
                "id": exp.id,
                "name": exp.name,
                "category": exp.get_category_display(),
                "city": exp.city.name if exp.city else "N/A",
                "selection_count": exp.selection_count,
                "base_price": exp.base_price,
                "is_active": exp.is_active,
            }
            for exp in top_experiences
        ]

    def _get_revenue_by_experience(self) -> List[Dict]:
        """Calculate revenue generated by each experience"""
        # Get all confirmed bookings with their experiences
        confirmed_bookings = Booking.objects.filter(status="CONFIRMED").prefetch_related(
            "selected_experiences"
        )

        # Calculate revenue per experience
        experience_revenue = {}
        for booking in confirmed_bookings:
            experiences = booking.selected_experiences.all()
            if experiences:
                # Distribute booking revenue proportionally among experiences
                revenue_per_exp = booking.total_price / len(experiences)
                for exp in experiences:
                    if exp.id not in experience_revenue:
                        experience_revenue[exp.id] = {
                            "experience": exp,
                            "revenue": Decimal("0.00"),
                            "booking_count": 0,
                        }
                    experience_revenue[exp.id]["revenue"] += revenue_per_exp
                    experience_revenue[exp.id]["booking_count"] += 1

        # Sort by revenue and get top 10
        sorted_revenue = sorted(
            experience_revenue.values(),
            key=lambda x: x["revenue"],
            reverse=True,
        )[:10]

        return [
            {
                "id": item["experience"].id,
                "name": item["experience"].name,
                "category": item["experience"].get_category_display(),
                "revenue": float(item["revenue"]),
                "booking_count": item["booking_count"],
                "avg_revenue_per_booking": float(
                    item["revenue"] / item["booking_count"]
                ),
            }
            for item in sorted_revenue
        ]

    def _get_category_statistics(self) -> List[Dict]:
        """Get selection rate and revenue by category"""
        categories = Experience.CATEGORY_CHOICES

        category_stats = []
        for category_code, category_name in categories:
            # Count selections
            selection_count = (
                Experience.objects.filter(
                    category=category_code,
                    booking__status__in=["CONFIRMED", "PENDING_PAYMENT"],
                )
                .values("id")
                .distinct()
                .count()
            )

            # Count total experiences in category
            total_in_category = Experience.objects.filter(
                category=category_code, is_active=True
            ).count()

            # Calculate selection rate
            selection_rate = (
                (selection_count / total_in_category * 100)
                if total_in_category > 0
                else 0
            )

            category_stats.append(
                {
                    "category": category_name,
                    "total_experiences": total_in_category,
                    "selected_count": selection_count,
                    "selection_rate": round(selection_rate, 2),
                }
            )

        return sorted(category_stats, key=lambda x: x["selection_rate"], reverse=True)

    def _get_city_statistics(self) -> List[Dict]:
        """Get experience statistics by city"""
        city_stats = (
            Experience.objects.filter(is_active=True, city__isnull=False)
            .values("city__name")
            .annotate(
                total_experiences=Count("id"),
                avg_price=Sum("base_price") / Count("id"),
                selection_count=Count(
                    "booking",
                    filter=Q(booking__status__in=["CONFIRMED", "PENDING_PAYMENT"]),
                ),
            )
            .order_by("-selection_count")[:10]
        )

        return [
            {
                "city": stat["city__name"],
                "total_experiences": stat["total_experiences"],
                "avg_price": float(stat["avg_price"]) if stat["avg_price"] else 0,
                "selection_count": stat["selection_count"],
            }
            for stat in city_stats
        ]

    def _get_recent_trends(self) -> Dict:
        """Get recent trends (last 30 days vs previous 30 days)"""
        from datetime import datetime, timedelta

        now = datetime.now()
        last_30_days = now - timedelta(days=30)
        previous_30_days = now - timedelta(days=60)

        # Bookings in last 30 days
        recent_bookings = Booking.objects.filter(
            created_at__gte=last_30_days, status__in=["CONFIRMED", "PENDING_PAYMENT"]
        ).count()

        # Bookings in previous 30 days
        previous_bookings = Booking.objects.filter(
            created_at__gte=previous_30_days,
            created_at__lt=last_30_days,
            status__in=["CONFIRMED", "PENDING_PAYMENT"],
        ).count()

        # Calculate growth
        growth = (
            ((recent_bookings - previous_bookings) / previous_bookings * 100)
            if previous_bookings > 0
            else 0
        )

        # Most popular experience in last 30 days
        popular_recent = (
            Experience.objects.filter(
                booking__created_at__gte=last_30_days,
                booking__status__in=["CONFIRMED", "PENDING_PAYMENT"],
            )
            .annotate(count=Count("booking"))
            .order_by("-count")
            .first()
        )

        return {
            "recent_bookings": recent_bookings,
            "previous_bookings": previous_bookings,
            "growth_percentage": round(growth, 2),
            "trending_experience": popular_recent.name if popular_recent else "N/A",
        }

    def _get_summary_statistics(self) -> Dict:
        """Get overall summary statistics"""
        total_experiences = Experience.objects.filter(is_active=True).count()
        total_bookings = Booking.objects.filter(
            status__in=["CONFIRMED", "PENDING_PAYMENT"]
        ).count()

        # Total revenue from confirmed bookings
        total_revenue = (
            Booking.objects.filter(status="CONFIRMED").aggregate(Sum("total_price"))[
                "total_price__sum"
            ]
            or 0
        )

        # Average experiences per booking
        avg_experiences = (
            Booking.objects.filter(status__in=["CONFIRMED", "PENDING_PAYMENT"])
            .annotate(exp_count=Count("selected_experiences"))
            .aggregate(avg=Sum("exp_count") / Count("id"))["avg"]
            or 0
        )

        return {
            "total_active_experiences": total_experiences,
            "total_bookings": total_bookings,
            "total_revenue": float(total_revenue),
            "avg_experiences_per_booking": round(float(avg_experiences), 2),
        }
